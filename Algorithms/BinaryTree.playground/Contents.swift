import Foundation


class BinaryNode<Element> {
    
    
    var value: Element
    var leftChild: BinaryNode?
    var rightChild: BinaryNode?
    
    
    init(value: Element) {
        self.value = value
    }
}


// Поскольку мы знаем, что двоичное дерево - это просто комбинация разных узлов, поэтому мы создадим отдельный класс для хранения данных, связанных с одним узлом.

// В нашем классе BinaryNodeесть три разных элемента.

//Value -> Это будет содержать значение узла. Например, мы можем создать целочисленное двоичное дерево, которое может содержать любое целочисленное значение.
//LeftChild  -> Левый дочерний элемент - это тип двоичного узла, и это необязательное значение, потому что узел может иметь или не может иметь дочерний узел.
//RightChild -> Правый дочерний элемент также является типом двоичного узла и по той же причине сделан необязательным.


var binaryTree: BinaryNode<Int> = {
    // шаг 1
    
    let rootNode = BinaryNode(value: 7)
    
    // шаг 2
    
    let oneNode = BinaryNode(value: 1)
    let twoNode = BinaryNode(value: 2)
    let threeNode = BinaryNode(value: 3)
    
    let sixNode = BinaryNode(value: 6)
    let eightNode = BinaryNode(value: 8)
    let nineNode = BinaryNode(value: 9)
    
    // шаг 3
    
    rootNode.leftChild = oneNode
    rootNode.rightChild = twoNode
    
    
    // шаг 4
    
    oneNode.leftChild = threeNode
    oneNode.rightChild = eightNode
    
    // шаг 5
    
    twoNode.leftChild = nineNode
    twoNode.rightChild = sixNode
    
    // шаг 6
    
    return rootNode
}()

// шаг 1 -> Мы создаем корневой узел с целочисленным значением 7.
//шаг 2-> На этом этапе мы создаем все оставшиеся узлы дерева.
//шаг 3-> Мы добавляем Node -> 1и Node -> 2как левый и правый дочерний элементNode -> 7
//шаг  4-> Мы добавляем Node -> 3и Node -> 8как левый и правый дочерний элементNode -> 1
//шаг 5-> Мы добавляем Node -> 9и Node -> 6как левый и правый дочерний элементNode -> 2
//шаг 6 -> Мы просто возвращаем корневой узел, который будет стартовым узлом нашего binaryTree

/*
 Основное правило обхода по порядку: в основном это означает, что для каждого посещаемого вами узла сначала выводится левый дочерний элемент, затем сам узел и, в конце концов, правый дочерний элемент. Для приведенного выше рисунка обход в порядке будетLeft child -> Parent -> Right child
 Inorder -> 3 1 8 7 9 2 6
 начнем с корневого узла и продолжим движение, пока не найдем крайний левый дочерний узел (в нашем случае это так Node -> 3). После этого мы перейдем к родительскому узлу, который является, Node -> 1а затем к правому дочернему узлу, который являетсяNode -> 8
    продолжим процесс left -> parent -> rightдо тех пор, пока все узлы не будут посещены. Поскольку посетили левый дочерний Node -> 7 элемент, теперь посетим, Node -> 7 а затем найдем самого левого дочернего элемента в правом поддереве. В данном случае Node -> 9 это крайний левый дочерний элемент, а затем Node -> 2 и Node -> 6
    можем создать расширение, по BinaryNodeкоторому будет проходить двоичное дерево, используяInorder traversal
 */

extension BinaryNode {
    
    
    func traverseInorder() {
        leftChild?.traverseInorder()
        print(value)
        rightChild?.traverseInorder()
    }
}
binaryTree.traverseInorder()
// Сначала вызываем, leftChild?.traverseInorder()который рекурсивно найдет самый левый дочерний элемент, а когда будет левый дочерний элемент, nil он распечатает значение, а затем перейдет к родительскому узлу, а затем к правому дочернему элементу.


/*
 Основное правило обхода перед порядком: в Parent -> Left child -> Right child
 основном это означает, что для каждого посещаемого узла сначала выводится его значение, затем его левый дочерний элемент, а затем правый дочерний элемент. Для этой же фигуры обход предварительного заказа будет Preorder -> 7 1 3 8 2 9 6

 Мы добавим в BinaryNodeрасширение еще одну функцию, которая будет использоваться для обхода двоичного дерева в порядке предварительного заказа.
 
 */

extension BinaryNode {
    
    func traversePreorder() {
        print(value)
        leftChild?.traversePreorder()
        rightChild?.traversePreorder()
    }
}
binaryTree.traversePreorder()


/*
 Сначала печатаем значение родительского узла, а затем рекурсивно посещаем левый дочерний элемент до тех пор, пока значение не станет равным, nilа затем мы рекурсивно посещаем правый дочерний узел, пока значение не станет равным, nil и распечатаем его значение.
 */


/*
 Основное правило обхода после порядка: Left child -> Right child -> Parent
 Это в основном означает, что для каждого узла сначала посещаем и печатаем левый дочерний элемент, затем правый дочерний элемент и, в конце концов, сам узел. Для того же дерева обход постоператора будетPostorder -> 3 8 1 9 6 2 7

  добавим в BinaryNodeрасширение еще одну функцию, которая будет использоваться для обхода двоичного дерева в поступорядоченном режиме.
 */

extension BinaryNode {
    
    func traversePostorder() {
        print(value)
        leftChild?.traversePostorder()
        rightChild?.traversePostorder()
    }
}
binaryTree.traversePostorder()
/*
 Сначала рекурсивно вызываем левый дочерний элемент и печатаем его значение, когда левый дочерний элемент равен нулю, затем рекурсивно вызываем left и выводим его значение, когда правый дочерний элемент равен нулю, и в конце мы распечатываем значение родительского узла.
 
 
 */
