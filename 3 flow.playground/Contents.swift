// 3 поток
// Задача 1 - Функция принимает на вход 2 катета прямоугольного треугольника. Вернуть в tuple ( кортеж ) длину гипотенузы и площадь
import UIKit
import Foundation

func cathet(number1: Double , number2: Double) -> (Double , Double) { // функция которая принимает два аргумента Дабл, и возвращает кортеж из двух катетов.
   // переменная turple в которой я объявляю кортеж с типами знвчений
    var turple: (hipo1: Double , square: Double)
    // в 0 значении кортежа вычисляю гипотенузу
    turple.hipo1 = sqrt(number1 * number1 + number2 * number2)
    // нахожу через значение кортежа площадь
    turple.square = (number1 * number2) / 2
    return turple
}
cathet(number1: 3, number2: 4)

// Задача 2 - Функция принимает на вход целое число. Если оно двузначное - вернуть массив всех нечетных чисел, не больше этого числа кроме 12,23 и 91. Если оно однозначное - вернуть массив всех целых чисел, не больше этого числа.
import Foundation

    func numbers(arg: Int) -> [Int] { // функция в которой присвоили целочисленный аргумент в котором возвращаем массив целых чисел
   // переменная array ,в которой возвращаю пустой массив
    var array = [Int]()
        // переменная variable в которой присваиваю 1
    var variable: Int = 1
        // условие для двузначного, если aргумент больше либо равен 10 и аргумент меньше 100
        if arg >= 10 && arg < 100 {
            // приисваиваем переменной значение 11
        variable = 11
            // цикл , где variable меньше аргумента
            while variable < arg {
                // условие если variable меньше либо равно 23 и меньше либо равен 91
                if variable != 23 && variable != 91 {
                    // применяем свойство к array в котором вставляем variable
                    array.append(variable)
                }
                // далее к переменной присваиваем + 2
                variable = variable + 2
            }
            // иначе если аргумент меньше либо равен 9
        } else if arg <= 9 {
            // то переменной присваиваем значение 1
            variable = 1
            // далее цикл где variable меньше аргумента
            while variable < arg {
                //применяем свойство к array в котором вставляем variable
                array.append(variable)
                //далее к переменной присваиваем + 1
                variable = variable + 1
            }
        }
        // возвращаем массив
        return array
}

print(numbers(arg: 78))

// Задача 3 - Функция принимает на вход неотсортированный массив целых чисел. Вернуть минимальное и максимальное число в tuple.
import UIKit
func staff(x: [Int]) -> (Int, Int) { // функция массив целых чисел возвращает кортеж
    //создаем кортеж с нулевым и первым значением массива x
    var minmax = (x[0], x[1])
    //цикл для i из массива x
    for i in x {
        //если нулевой элемент переменной minmax больше i - текущего элемента из х
        if minmax.0 > i {
            //в нулевой элемент minmax записываем i - текущий элемент из х
            minmax.0 = i
            //иначе если первый элемент переменной minmax больше i
        } else if minmax.1 < i {
             //в первый  элемент minmax записываем i - текущий элемент из х
            minmax.1 = i
        }
    } //вывод minmax
    return minmax
}
print(staff(x: [1, 2, 3, 4, 5, 67]))


// Задача 4 - Функция принимает на вход массив целых чисел. Напечатать все числа, находящиеся на нечетных позициях.
//функция array принимает на вход массив целых чисел arr
func array(arr:[Int]) -> Void {
    //цикл от нуля до размера массива
    for i in 0...arr.count {
        //если индекс элемента в массиве не делится на 2
        if i % 2 == 1 {
            //вывести элемент массива с этим индексом
            print(arr[i])
        }
    }
}
array(arr:[1, 2, 3, 4, 5, 6])

// Задача 5 - Написать функцию, принимающую на вход 2 целых числа. Вернуть факториал первого аргумента, если значение факториала меньше или равно второму аргументу. Иначе вернуть второй аргумент
func numbers(number1: Int , number2: Int) -> Int { // функция вход два целых числа возвращает целое число
    // переменная факториал = 1
    var factorial = 1
   // цикл где диапазон от 1 до аргумента 1
    for i in 1...number1 {
    // переменную факториал умножаем = 1
        factorial *= i
    }
    // если факторил меньше или раньше второму аргументу
    if factorial <= number2 {
    // то ретерним факториал
        return factorial
        // иначе
    } else {
    // ретерним аргумент2
        return number2
    }
}

// Задача 6 -Написать функцию, печатающую входной массив в обратном порядке (reversed())
func numbers(number: [Int]) -> [Int] { //  Функция в которой массив целых чисел возвращает массив
    // возвращаем массив через свойство в обратном порядке
    return number.reversed()

}
numbers(number: [1,2,4,5])

// Задача 7 - На вход функции 2 массива целых чисел. Первый - исследуемый, второй - фильтрующий. Вернуть из функции массив чисел, не входящих в исследуемый массив.  ( у массива есть функция contains() - вызывается так же, как append() )
func exit(research: [Int], filter: [Int] ) -> [Int] { // Функция exit в которой два массива исследуемый и фильтрующий и возвращаем массив
    // переменная exitarray присваиваем пустой массив
    var exitarray = [Int]()
    // делаем цикл для элемента до фильтрующий массива
    for i in filter {
        // если в исследуемом массиве не содержится элемент фильтрующего
        if !research.contains(i){
            // то в пустой массив добавляем элемент фильтрующего
            exitarray.append(i)
        }
    }
    // возвращаем отфильтрованный массив
    return exitarray
}

// Задача 8 - То же, но вернуть массив чисел, не входящих в фильтрующий массив
func exit2(research: [Int], filter: [Int] ) -> [Int] { // Функция exit в которой два массива исследуемый и фильтрующий и возвращаем массив
// переменная exitarray присваиваем пустой массив
var exitarray = [Int]()
// делаем цикл для элемента до исследуемого массива
for i in research {
    // если в фильтрующем массиве не содержится элемент фильтрующего
    if !filter.contains(i){
        // то в пустой массив добавляем элемент фильтрующего
        exitarray.append(i)
    }
}
// возвращаем отфильтрованный массив
return exitarray
}

// Задача 9 - Написать функцию-оболочку функций из 7 и 8 задачи. Она принимает на вход 2 массива (исследуемый и фильтрующий) и третий аргумент - строка String, задающий режим работы.
//Если режим работы - “new” - вызываем функцию из п.7 и возвращаем массив.
//Если режим работы - “outdated” - вызываем функцию

func array(research1: [Int] , filter1:[Int] , string: String ) -> Void  { // функция в которой три аргумента 2 целочисленных , один строковый не возврвщает ничего
   // если строке присвоим new
   if string == "new" {
   // вызываем функция из 7 задачи
        exit(research: research1, filter: filter1)
        // иначе если строка outdated
    } else if string == "outdated" {
    // вызываем функцию из задачи 8
        exit2(research: research1, filter: filter1)
    }
}

// Задача 10 - Числа Фибоначчи . Первое - 0, второе - 1. Третье - 0+1 = 1 Четвертое - 0 +1 + 1 = 2 Пятое - 0 + 1 + 1 + 2 = 4 и т д.
//Написать функцию, принимающую на вход N - целое число, номер числа фибоначчи. Вернуть из функции найденное число. ( используйте цикл от 0...N ).
//СЛОЖНА - подумайте и погуглите рекурсивную реализацию.\
import UIKit
func fibonachi(N: Int) -> Int { // функция в которой целое число возвращает целые числа
    // если аргумент меньше 1
    if N < 1 {
        // возвращаем 0
    return 0
    }
    // если N равно 1 или N равно 2
    if N == 1 || N == 2 {
        // то возвращаем 1
        return 1
    }
    // возвращаем сумму двух предыдущих элементов последовательности
    return fibonachi(N:N-1) + fibonachi(N:N-2)
}
fibonachi(N:7)
